- Class: meta
  Course: DataScienceAndR
  Lesson: RDataEngineer-05-Data-Manipulation
  Author: Wush Wu and Cheng-Yu Lin
  Type: Standard
  Organization: Taiwan R User Group
  Version: 2.3.1.1

- Class: text
  Output: 前半段的課程，大部分著重於從資料中萃取出資訊，並且整理成一個data.frame（結構化）。
    這門課程則是要開始討論，當資訊已經被結構化之後，我們要如何整理結構化的資料。

- Class: text
  Output: |
    R 有許多解決這類問題的函數，例如：`melt`、`subset`等等。族繁不及備載。這些函數的名稱
    不容易記憶，而且效能並不是很好。

- Class: text
  Output: |
    dplyr套件是Hadley Wickham和Romain Francois在2014上架的一個套件，是目前我認為是在R 做
    資料整理上最完善的套件之一。dplyr提供了直觀的函數，並且能夠和SQL expression做對應，效能
    也被Romain透過C++去優化過，種種優勢讓我決定跳過傳統R 整理資料的工具，直接教大家dplyr。

- Class: cmd_question
  Output: 請大家先安裝`dplyr`套件。
  CorrectAnswer: check_then_install("dplyr", "0.4.3")
  AnswerTests: test_package_version("dplyr", "0.4.3")

- Class: cmd_question
  Output: 接著請大家載入dplyr套件
  CorrectAnswer: test_search_path("dplyr")

- Class: cmd_question
  Output: 請同學輸入學套件的起手式：`vignette(package = "dplyr")`
  CorrectAnswer: vignette(package = "dplyr")
  AnswerTests: omnitest('vignette(package = "dplyr")')

- Class: text
  Output: Hadley等人都是開發R 套件界的大大，他們對vignette是非常重視的，所以我們會看到許多
    vignette。說實話，我個人寫的dplyr套件的介紹絕對也不會比Hadley大大他們寫的精彩。不過透過
    swirl的好處，就是我們可以把整個dplyr的功能走過一遍。

- Class: cmd_question
  Output: 請同學執行`vignette("introduction", package = "dplyr")`打開Introduction。
  CorrectAnswer: vignette("introduction", package = "dplyr")
  AnswerTests: omnitest('vignette("introduction", package = "dplyr")')

- Class: cmd_question
  Output: 簡單起見，我們直接跟著vignette，拿`nycflights13`裡面的`flights`資料集做練習。
    請同學先安裝`nycflights13`套件。
  CorrectAnswer: check_then_install("nycflights13", "0.1")
  AnswerTests: test_package_version("nycflights13", "0.1")
  Hint: install.packages("nycflights13")

- Class: cmd_question
  Output: 接著載入`nycflights13`套件。
  CorrectAnswer: library(nycflights13)
  AnswerTests: test_search_path("nycflights13")

- Class: text
  Output: 這個套件提供的flights資料集合，是所有於2013年在紐約起降的飛機資料。

- Class: cmd_question
  Output: Vignette中宣稱flights共有336776筆資料。我們應該要驗證一下，也順便讓同學複習
    data.frame的操作。請同學用指令查詢flights共有多少資料。
  CorrectAnswer: nrow(flights)
  AnswerTests: omnitest(correctVal = nrow(flights))

- Class: text
  Output: |
    dplyr中在處理data.frame的函數，共有：`filter`、`slice`、`arrange`、
    `select`、`distinct`、`mutate`、`summarise`和`sample_n`接下來的課程
    中，我們一邊操作，一邊講解。

- Class: cmd_question
  Output: |
    `filter`是用來做列方向的過濾，所以經過`filter`處理後，資料的個數（`nrow`）會
    下降。`filter`函數的用法是，第一個參數放我們要處理的data.frame，後面接各種過濾
    條件。例如：`filter(flights, month == 1, day == 1)`，請同學試試看。
  CorrectAnswer: filter(flights, month == 1, day == 1)
  AnswerTests: omnitest('filter(flights, month == 1, day == 1)')

- Class: text
  Output: |
    同學應該會注意到，輸出結果中`month`和`day`都是1 了。因為`filter`
    會把資料一筆一筆的對後面的語句（`month == 1`和`day == 1`）做檢查。R 在
    解析這些語句時，自動把這些變數對應到`flights`的欄位。所以在`filter`中的
    `month`就等同於`flights$month`，`day`就等同於`flights$day`

- Class: text
  Output: 熟悉SQL expression的同學請注意，`filter`就是SQL的`WHERE`。

- Class: script
  Output: |
    如果我們要使用RBasic系列所所使用的語法，要如何得到同樣的結果呢？請同學
    試著寫寫看。提示：兩個布林比較和一個`[`
  Script: RDataEngineer-05-01.R
  AnswerTests: test_equal(answer01, flights[flights$month == 1 & flights$day == 1,])

- Class: text
  Output: 為了降低難度，所以我們在scripts中讓大家是一步一步的做操作。實務上，熟悉R 的使用者
    會直接寫一行：`flights[flights$month == 1 & flights$day == 1,]`，這是一種程式碼的壓縮。

- Class: text
  Output: |
    程式碼的壓縮，讓使用者可以少打許多的字，和許多暫存變數，如剛剛寫的`month_is_1`、
    `day_is_1`和`is_target`等等。但是即使如此，dplyr提供的`filter`還是可以用更簡潔
    程式碼達到一樣的效果。背後的原因就在於`flights$month`和`flights$day`的`flights`
    被省略了。

- Class: text
  Output: |
    一般來說，`filter`的第一個參數代表要做處理的data.frame，而後面的參數通通都是條件。
    每個條件就是一個expression，並且輸出布林向量。`filter`只會回傳那些滿足所有條件的
    資料。

- Class: text
  Output: |
    這堂課程介紹的dplyr的函數，都具有一樣的性質：第一個參數是要處理的data.frame，而其餘
    的參數是各種expression，並且這些expression中的變數名稱，都會優先對應到data.frame
    中的欄位。

- Class: cmd_question
  Output: 請同學試著從`flights`中找出`flights$month`為 1，`flights$day`為2的資料。
  CorrectAnswer: filter(flights, month == 1, day == 2)
  AnswerTests: omnitest(correctVal = filter(flights, month == 1, day == 2))

- Class: script
  Output: 請問同學，在2013年的紐約，共有多少班次的飛機起飛有延誤？(`dep_delay > 0`)
  Script: RDataEngineer-05-02.R
  AnswerTests: test_equal(answer02, nrow(filter(flights, dep_delay > 0)))

- Class: text
  Output: |
    上一題的答案也是可以做程式碼的壓縮的。同學可以先用`filter(flights, dep_delay > 0)`
    篩選出資料集之後，直接把結果的值傳到`nrow`的第一個參數，也就是：
    `nrow(filter(flights, dep_delay > 0))`

- Class: cmd_question
  Output: |
    有時候我們希望找出符合某些條件的文字。舉例來說，如果我們要找出`tailnum`中包含有`"AA"`，要
    怎麼做呢？R 內建有一個`grepl`的函數可以解決這個問題。請同學先輸入`?grepl`打開他的說
    名文件。
  CorrectAnswer: ?grepl
  AnswerTests: any_of_exprs("?grepl", "help(grepl)", 'help("grepl")')

- Class: text
  Output: |
    `grepl`的參數很多，但是這裡我們只要學三個參數：`pattern`、`x`和、`fixed`就好。
    第一個參數`pattern`代表的是，我們要找的模式。舉例來說，如果我們要找`"AA"`，pattern
    就會是`"AA"`。但是如果`fixed = FALSE`狀態下，R 會使用「正則表示式」（Regular Expression）
    來處理`pattern`，有時候會有預期外的結果。這部份在同學學會正則表示式之前，都設定`fixed = TRUE`
    比較簡單。`x`則很單純，就是我們要搜尋文字。在這裡，就是`flights$tailnum`。

- Class: mult_question
  Output: |
    我們想輸出的程式碼是：`filter(flights, grepl(pattern = <1>, x = <2>, fixed = TRUE))`
    這裡透過適當的設定`grepl`的參數，就可以獲得我們想要的比對結果，也就是tailnum中
    是不是有包含`"AA"`這樣的文字的結果。而`filter`在利用這樣的結果對資料做篩選。
    請問同學，<1>應該要填寫什麼？
  AnswerChoices: |
    "AA";AA;flights;flights$tailnum
  CorrectAnswer: '"AA"'
  AnswerTests: omnitest(correctVal = '"AA"')

- Class: mult_question
  Output: |
    我們想輸出的程式碼是：`filter(flights, grepl(pattern = <1>, x = <2>, fixed = TRUE))`
    請問同學，<2>應該要填寫什麼？
  AnswerChoices: |
    "AA";AA;flights;flights$tailnum
  CorrectAnswer: 'flights$tailnum'
  AnswerTests: omnitest(correctVal = 'flights$tailnum')

- Class: mult_question
  Output: |
    在請問同學，`filter(flights, grepl(pattern = "AA", x = tailnum, fixed = TRUE))`
    是不是也成立呢？
  AnswerChoices: Yes;No
  CorrectAnswer: "Yes"
  AnswerTests: omnitest(correctVal = "Yes")

- Class: cmd_question
  Output: 最後請同學試試看：`filter(flights, grepl(pattern = "AA", x = tailnum, fixed = TRUE))`
  CorrectAnswer: filter(flights, grepl(pattern = "AA", x = tailnum, fixed = TRUE))
  AnswerTests: omnitest('filter(flights, grepl(pattern = "AA", x = tailnum, fixed = TRUE))')

- Class: text
  Output: |
    對`filter`的介紹差不多了。接下來我們介紹`slice`。
    `slice`很單純，`slice(flights, 1:6)`就等價於`flights[1:6,]`。

- Class: cmd_question
  Output: |
    我們直接練習，「用肌肉記憶」。請同學選出`flights`的第10000 到 第20000資料。
  CorrectAnswer: slice(flights, 10000:20000)
  AnswerTests: omnitest(correctVal = slice(flights, 10000:20000))

- Class: cmd_question
  Output: |
    接下來，我們練習`arrange`。`arrange`會把data.frame的資料，根據後面的expression
    做排序。請同學試試看：`arrange(flights, month, day, dep_time)`。給熟悉SQL的同學，
    `arrange`很類似SQL的`ORDER BY`
  CorrectAnswer: arrange(flights, month, day, dep_time)
  AnswerTests: omnitest('arrange(flights, month, day, dep_time)')

- Class: text
  Output: |
    我們仔細觀察上一題的輸出。`arrange`會先比較`month`的值，然後當`month`平手就比`day`，
    以此類推。所以我們會看到輸出的最前面，就是`month`、`day`最小的，平手的資料中，`dep_time`
    最小的。

- Class: mult_question
  Output: 所以我們能不能根據上面的結果判斷：`dep_time`的最小值是517呢？（第一列的dep_time）
  AnswerChoices: Yes;No
  CorrectAnswer: "No"
  AnswerTests: omnitest(correctVal = '"No"')

- Class: cmd_question
  Output: |
    我們是不能確定這件事情的，因為有些資料可能有更小的`dep_time`，但是他們的`day`和
    `month`太大，所以被排到後面。我們來找找看`dep_time`的最小值吧。請同學輸入：
    `min(flights$dep_time)`
  CorrectAnswer: min(flights$dep_time)
  AnswerTests: omnitest('min(flights$dep_time)')

- Class: cmd_question
  Output: |
    我們注意到dep_time的資料有missing data。導致上一題的輸出為`NA`。我們要怎麼忽略
    `NA`呢？請同學試試看：`min(flights$dep_time, na.rm = TRUE)`
  CorrectAnswer: min(flights$dep_time, na.rm = TRUE)
  AnswerTests: omnitest('min(flights$dep_time, na.rm = TRUE)')

- Class: cmd_question
  Output: |
    我們也可以把比較的順序從由小到大改成由大到小，只要加上`desc`就行了。
    舉例來說：`arrange(flights, desc(month), desc(day), desc(dep_time))`
    請試試看。
  CorrectAnswer: arrange(flights, desc(month), desc(day), desc(dep_time))
  AnswerTests: omnitest('arrange(flights, desc(month), desc(day), desc(dep_time))')

- Class: cmd_question
  Output: |
    接下來我們來介紹`select`。通常一個很大的data.frame中，我們一次只會對少數幾欄有興趣，
    `select`可以讓我們挑出我們有興趣的欄位。
    請同學試試看：`select(flights, year, month, day)`
  CorrectAnswer: select(flights, year, month, day)
  AnswerTests: omnitest('select(flights, year, month, day)')

- Class: cmd_question
  Output: 我們先看看`flights`的欄位名稱與排序。請同學複習一下。
  CorrectAnswer: colnames(flights)
  AnswerTests: omnitest(correctVal = colnames(flights))

- Class: cmd_question
  Output: |
    我們也可以用`select(flights, year:day)`來選取`year`和`day`之間的欄位。請同學
    試試看。
  CorrectAnswer: select(flights, year:day)
  AnswerTests: omnitest('select(flights, year:day)')

- Class: cmd_question
  Output: |
    如果是要反面選取，剃除掉`year`到`day`之間的欄位，只要使用：
    `select(flights, -(year:day))`。請同學試試看。
  CorrectAnswer: select(flights, -(year:day))
  AnswerTests: omnitest('select(flights, -(year:day))')

- Class: cmd_question
  Output: 在`select`的過程中，我們也可以重新命名資料的欄位。
    請同學試試看：`select(flights, tail_num = tailnum)`
  CorrectAnswer: select(flights, tail_num = tailnum)
  AnswerTests: omnitest(select(flights, tail_num = tailnum))

- Class: script
  Output: |
    這裡出一個小問題讓大家練習：請同學選出`flights`中`dep_time`為NA的資料，並只挑出
    `year`、`month`和`day`這三欄。
  Script: RDataEngineer-05-03.R
  AnswerTests: test_equal(answer03, select(filter(flights, is.na(dep_time)), year:day))

- Class: text
  Output: |
    `cl_info_other`是取自金管會銀行局的一般銀行及信用合作社消費者貸款業務項目，原始資料是
    一系列的excel檔案。
